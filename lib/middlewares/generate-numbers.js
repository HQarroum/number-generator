import fs from 'fs';
import prettyBytes from 'pretty-bytes';
import ora from 'ora';
import signale from 'signale';
import prompt from 'prompts';
import { Generator } from '../generator.js';

/**
 * @param {*} size the size in bytes to pretty print.
 * @returns a pretty representation of the given size. 
 */
const sizeStats = (size) => `Generated (${prettyBytes(size)})`;

/**
 * @returns a new generator instance based
 * on the provided options.
 */
const createGenerator = (input) => new Generator({
  engine: input.opts.engine,
  number: input.opts.amount,
  minNumber: input.opts.minNumber,
  maxNumber: input.opts.maxNumber,
  chunkSize: input.opts.chunkSize,
  threadCount: input.opts.threadCount,
  format: input.opts.format
});

/**
 * Prompts the user to confirm that the size of the
 * dataset is appropriate.
 * @param {*} size the size of the generated dataset.
 */
const promptSize = (size) => {
  return (prompt({
    type: 'confirm',
    name: 'confirm',
    message: `The estimated size of the generated dataset will be ${prettyBytes(size)}, do you want to continue?`
  }));
};

/**
 * Generates the random numbers.
 * @middleware
 */
export default async (input, _, next) => {
  const stats     = { total: 0 };
  const generator = createGenerator(input);
  let spinner     = null;

  // Prompting the user to confirm the estimated size of the dataset.
  if (!input.opts.yes) {
    const result = await promptSize(input.generator.estimatedSize(input.opts.amount));
    if (!result.confirm) {
      signale.error('Aborting');
      process.exit();
    }
  }

  // Printing information about the operation.
  if (input.opts.output) {
    signale.info(`Generating ${generator.numbers()} number(s)`);
    signale.info(`Using ${generator.chunks()} chunk(s) of ${generator.chunkSize()} numbers`);
    signale.info(`Using ${generator.workerThreads()} thread(s)`);
    spinner = ora(sizeStats(0)).start();
  }

  // Creating the number generator.
  const emitter = generator.generate();

  // Listening for each generated chunk.
  emitter.on('chunk', (result) => {
    // Counting the number of bytes generated.
    stats.total += result.size;

    if (input.opts.output) {
      spinner.text = sizeStats(stats.total);
    }
    // Writing the generated bytes to the output file.
    if (input.opts.output) {
      fs.appendFileSync(input.opts.output, result.array);
    } else {
      process.stdout.write(result.array);
    }
  });

  // Listening for the end of the generation.
  emitter.on('end', () => {
    if (input.opts.output) {
      spinner.succeed();
    }
    next(input.stats = stats);
  });
};
